{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Prajanya/SmartParking/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from \"@supabase/ssr\"\r\nimport { cookies } from \"next/headers\"\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,   // â† USE SERVICE ROLE KEY HERE\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // Ignore for server components\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,gFAEvB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,+BAA+B;gBACjC;YACF;QACF;IACF;AAEJ"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Prajanya/SmartParking/app/api/sensors/webhook/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/supabase/server\"\r\n\r\ninterface SensorDistances {\r\n  centre_distance: number\r\n  left_distance: number\r\n  right_distance: number\r\n  timestamp?: number\r\n}\r\n\r\ninterface ParkingAnalysis {\r\n  status: \"occupied\" | \"empty\" | \"entering\" | \"exiting\"\r\n  alignment: \"centered\" | \"left_biased\" | \"right_biased\" | \"severely_misaligned\"\r\n  quality_score: number\r\n  is_misparked: boolean\r\n  warnings: string[]\r\n  metrics: {\r\n    center_offset_cm: number\r\n    angle_deviation_deg: number\r\n    space_utilization: number\r\n  }\r\n}\r\n\r\nfunction analyzeParkingQuality(distances: SensorDistances): ParkingAnalysis {\r\n  const { centre_distance, left_distance, right_distance } = distances;\r\n\r\n  const warnings: string[] = [];\r\n\r\n  // ===== STATUS LOGIC =====\r\n  // New logic:\r\n  // - If all distances are large (>= UNOCCUPIED_DISTANCE) and roughly equal -> empty\r\n  // - If centre is close (<= OCCUPIED_THRESHOLD) and left/right are symmetric -> occupied\r\n  // - If centre indicates occupied but left/right are noticeably asymmetric -> misparked\r\n  const UNOCCUPIED_DISTANCE = 200 // cm - distances this large indicate no vehicle\r\n  const UNOCCUPIED_TOLERANCE = 10 // cm tolerance for 'equal' when unoccupied\r\n  const OCCUPIED_THRESHOLD = 80 // cm - centre distance below this indicates vehicle present\r\n\r\n  // Quick empty check: all distances large and roughly equal\r\n  const maxDist = Math.max(centre_distance, left_distance, right_distance)\r\n  const minDist = Math.min(centre_distance, left_distance, right_distance)\r\n  if (minDist >= UNOCCUPIED_DISTANCE && (maxDist - minDist) <= UNOCCUPIED_TOLERANCE) {\r\n    return {\r\n      status: \"empty\",\r\n      alignment: \"centered\",\r\n      is_misparked: false,\r\n      quality_score: 100,\r\n      warnings: [],\r\n      metrics: {\r\n        center_offset_cm: centre_distance,\r\n        angle_deviation_deg: 0,\r\n        space_utilization: 0,\r\n      },\r\n    }\r\n  }\r\n\r\n  // If centre indicates occupied, proceed to alignment checks\r\n  const status: ParkingAnalysis[\"status\"] = centre_distance <= OCCUPIED_THRESHOLD ? \"occupied\" : \"empty\";\r\n\r\n  // ===== ALIGNMENT LOGIC =====\r\n  const alignmentDiff = Math.abs(left_distance - right_distance);\r\n  const alignmentThreshold = 10; // distances within 10cm considered symmetric\r\n  const MISPARK_THRESHOLD = 25; // above this considered misparked\r\n  const severeMisalignThreshold = 80; // keep severe threshold for extreme cases\r\n\r\n  let alignment: ParkingAnalysis[\"alignment\"];\r\n\r\n\r\n  if (alignmentDiff <= alignmentThreshold) {\r\n    alignment = \"centered\";\r\n  } else if (alignmentDiff <= MISPARK_THRESHOLD) {\r\n    // Some bias but still acceptable parking (slightly off-center)\r\n    alignment = left_distance < right_distance ? \"left_biased\" : \"right_biased\";\r\n    warnings.push(`Vehicle slightly ${alignment.replace(\"_\", \" \")} by ${alignmentDiff.toFixed(1)}cm`);\r\n  } else if (alignmentDiff < severeMisalignThreshold) {\r\n    // Significant bias - treat as misparked\r\n    alignment = left_distance < right_distance ? \"left_biased\" : \"right_biased\";\r\n    warnings.push(`Misparking suspected: ${alignment.replace(\"_\", \" \")} by ${alignmentDiff.toFixed(1)}cm`);\r\n  } else {\r\n    alignment = \"severely_misaligned\";\r\n    warnings.push(`Severe misalignment detected: ${alignmentDiff.toFixed(1)}cm difference`);\r\n  }\r\n\r\n  // ===== MISPARKED LOGIC =====\r\n  const is_misparked = alignment === \"severely_misaligned\" || alignmentDiff >= MISPARK_THRESHOLD\r\n\r\n  // ===== MINIMAL METRICS RETURNED =====\r\n  return {\r\n    status,\r\n    alignment,\r\n    is_misparked,\r\n    quality_score: is_misparked ? 0 : 100, // keep field for compatibility\r\n    warnings,\r\n    metrics: {\r\n      center_offset_cm: centre_distance, // simply return raw values\r\n      angle_deviation_deg: 0,            // ignored\r\n      space_utilization: 0               // ignored\r\n    },\r\n  };\r\n}\r\n\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n\r\n    // Distances MUST come in the JSON body with these exact keys:\r\n    // `left_distance`, `centre_distance`, `right_distance` (all in cm)\r\n    const left_distance = body.left_distance !== undefined ? Number(body.left_distance) : undefined\r\n    const centre_distance = body.centre_distance !== undefined ? Number(body.centre_distance) : undefined\r\n    const right_distance = body.right_distance !== undefined ? Number(body.right_distance) : undefined\r\n\r\n    // The ESP32 will POST only the three distances in the JSON body.\r\n    // Identify the lot and spot via headers when available (x-lot-id, x-spot-number).\r\n    const spot_number = request.headers.get(\"x-spot-number\") || \"A36\"\r\n    const lotId = request.headers.get(\"x-lot-id\") || \"4a41c3f7-015d-44eb-8d63-c22f101c1c36\"\r\n    const timestamp = body.timestamp || Date.now()\r\n\r\n    console.log(\"[v0] Sensor webhook received:\", {\r\n      spot_number,\r\n      lotId,\r\n      distances: { centre_distance, left_distance, right_distance },\r\n    })\r\n\r\n    if (\r\n      centre_distance === undefined ||\r\n      left_distance === undefined ||\r\n      right_distance === undefined\r\n    ) {\r\n      return NextResponse.json(\r\n        {\r\n          error:\r\n            \"Missing required distance fields in body: left_distance, centre_distance, right_distance\",\r\n        },\r\n        { status: 400 },\r\n      )\r\n    }\r\n\r\n    const supabase = await createClient()\r\n\r\n    // Require lot identification via header `x-lot-id` (or body fallback). Without lotId\r\n    // we cannot insert a parking_events row because `lot_id` is required by the schema.\r\n    if (!lotId) {\r\n      return NextResponse.json({ error: \"Missing lot identification header: x-lot-id\" }, { status: 400 })\r\n    }\r\n\r\n    if (!spot_number) {\r\n      return NextResponse.json({ error: \"Missing spot identification header: x-spot-number\" }, { status: 400 })\r\n    }\r\n\r\n    // Fetch lot info for push notifications and available_spots\r\n    const { data: lot, error: lotError } = await supabase.from(\"parking_lots\").select(\"*\").eq(\"id\", lotId).single()\r\n    if (lotError || !lot) {\r\n      console.error(\"[v0] Lot not found:\", lotError)\r\n      return NextResponse.json({ error: \"Invalid lot id\" }, { status: 400 })\r\n    }\r\n\r\n    // Fetch last two sensor events for this lot & spot to determine stability\r\n    const { data: prevEvents } = await supabase\r\n      .from(\"parking_events\")\r\n      .select(\"sensor_data\")\r\n      .eq(\"lot_id\", lotId)\r\n      .eq(\"spot_number\", spot_number)\r\n      .order(\"detected_at\", { ascending: false })\r\n      .limit(2)\r\n\r\n    // parse last two raw distances if available\r\n    const prevReadings: SensorDistances[] = []\r\n    if (prevEvents && Array.isArray(prevEvents)) {\r\n      for (const ev of prevEvents) {\r\n        try {\r\n          const raw = (ev as any).sensor_data?.raw_distances\r\n          if (raw && raw.left_distance !== undefined && raw.centre_distance !== undefined && raw.right_distance !== undefined) {\r\n            prevReadings.push({\r\n              left_distance: Number(raw.left_distance),\r\n              centre_distance: Number(raw.centre_distance),\r\n              right_distance: Number(raw.right_distance),\r\n            })\r\n          }\r\n        } catch {}\r\n      }\r\n    }\r\n\r\n    const lastTwoSame = prevReadings.length === 2 &&\r\n      prevReadings[0].left_distance === prevReadings[1].left_distance &&\r\n      prevReadings[0].centre_distance === prevReadings[1].centre_distance &&\r\n      prevReadings[0].right_distance === prevReadings[1].right_distance\r\n\r\n    // Compute current analysis using the canonical keys\r\n    const analysis = analyzeParkingQuality({\r\n      centre_distance: Number(centre_distance),\r\n      left_distance: Number(left_distance),\r\n      right_distance: Number(right_distance),\r\n      timestamp,\r\n    })\r\n\r\n    // Map analysis.status/alignment to simplified parking_status: misparked | parked | empty\r\n    let parking_status: \"misparked\" | \"parked\" | \"empty\" = \"empty\"\r\n    if (analysis.is_misparked && analysis.status === \"occupied\") parking_status = \"misparked\"\r\n    else if (analysis.status === \"occupied\") parking_status = \"parked\"\r\n    else parking_status = \"empty\"\r\n\r\n    // Determine last stable status (if last two readings were stable)\r\n    let lastStableStatus: \"misparked\" | \"parked\" | \"empty\" | null = null\r\n    if (lastTwoSame) {\r\n      const last = prevReadings[0]\r\n      const lastAnalysis = analyzeParkingQuality(last)\r\n      if (lastAnalysis.is_misparked && lastAnalysis.status === \"occupied\") lastStableStatus = \"misparked\"\r\n      else if (lastAnalysis.status === \"occupied\") lastStableStatus = \"parked\"\r\n      else lastStableStatus = \"empty\"\r\n    }\r\n\r\n    // Detect transition only when prior state was stable. If prior state unstable, ignore transitions.\r\n    let transition: \"entry\" | \"exit\" | \"none\" = \"none\"\r\n    if (lastStableStatus !== null) {\r\n      if (lastStableStatus === \"empty\" && parking_status !== \"empty\") transition = \"entry\"\r\n      else if (lastStableStatus !== \"empty\" && parking_status === \"empty\") transition = \"exit\"\r\n    }\r\n\r\n    // Find active booking for this spot\r\n    const now = new Date().toISOString()\r\n    const { data: activeBooking } = await supabase\r\n      .from(\"bookings\")\r\n      .select(\"*\")\r\n      .eq(\"lot_id\", lotId)\r\n      .eq(\"spot_number\", spot_number)\r\n      .eq(\"status\", \"active\")\r\n      .lte(\"start_date\", now)\r\n      .gte(\"end_date\", now)\r\n      .single()\r\n\r\n    // Capture prior booking parking_status (fetched from DB) for before/after logging\r\n    const priorBookingStatus = activeBooking?.parking_status ?? null\r\n    if (activeBooking) {\r\n      console.log(\"[v0] Prior booking.parking_status from DB:\", { bookingId: activeBooking.id, priorBookingStatus })\r\n    }\r\n\r\n    // Determine event type based on detected transition and parking status\r\n    let event_type: \"sensor_update\" | \"entry\" | \"exit\" | \"misparked\" = \"sensor_update\"\r\n    if (transition === \"entry\") event_type = \"entry\"\r\n    else if (transition === \"exit\") event_type = \"exit\"\r\n    else if (parking_status === \"misparked\") event_type = \"misparked\"\r\n\r\n    // Create parking event with full analysis\r\n    // Log final calculated parameters using the JSON keys the ESP32 sends\r\n    console.log(\"[v0] Computed sensor params:\", {\r\n      left_distance,\r\n      centre_distance,\r\n      right_distance,\r\n      stable: lastTwoSame,\r\n      transition,\r\n      parking_status,\r\n      event_type,\r\n      spot_number,\r\n      lotId,\r\n      timestamp,\r\n    })\r\n\r\n    const { data: event, error: eventError } = await supabase\r\n      .from(\"parking_events\")\r\n      .insert({\r\n        lot_id: lotId,\r\n        booking_id: activeBooking?.id || null,\r\n        spot_number,\r\n        event_type,\r\n        sensor_data: {\r\n          raw_distances: { centre_distance: Number(centre_distance), left_distance: Number(left_distance), right_distance: Number(right_distance) },\r\n          analysis,\r\n          stable: lastTwoSame,\r\n          transition,\r\n          parking_status,\r\n          timestamp,\r\n        },\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (eventError) {\r\n      console.error(\"[v0] Error creating parking event:\", eventError)\r\n      return NextResponse.json({ error: \"Failed to create parking event\" }, { status: 500 })\r\n    }\r\n\r\n    // Update booking.parking_status for the active booking (if one exists)\r\n    if (activeBooking) {\r\n      let bookingParkingStatus: string | null = null\r\n      if (parking_status === \"misparked\") bookingParkingStatus = \"misparked\"\r\n      else if (parking_status === \"parked\") bookingParkingStatus = \"normal\"\r\n      else if (parking_status === \"empty\") bookingParkingStatus = \"normal\"\r\n\r\n      if (bookingParkingStatus && activeBooking.parking_status !== bookingParkingStatus) {\r\n        try {\r\n          await supabase\r\n            .from(\"bookings\")\r\n            .update({ parking_status: bookingParkingStatus })\r\n            .eq(\"id\", activeBooking.id)\r\n        } catch (err) {\r\n          console.error(\"[v0] Failed to update booking parking_status:\", err)\r\n        }\r\n      }\r\n    }\r\n\r\n    // After processing, fetch latest parking_status from DB and log before/after\r\n    if (activeBooking) {\r\n      try {\r\n        const { data: latestBooking } = await supabase\r\n          .from(\"bookings\")\r\n          .select(\"parking_status\")\r\n          .eq(\"id\", activeBooking.id)\r\n          .single()\r\n\r\n        console.log(\"[v0] Booking.parking_status before/after:\", {\r\n          bookingId: activeBooking.id,\r\n          before: priorBookingStatus,\r\n          after: latestBooking?.parking_status ?? null,\r\n        })\r\n      } catch (err) {\r\n        console.error(\"[v0] Failed to fetch latest booking.parking_status:\", err)\r\n      }\r\n    }\r\n\r\n    // Handle misparking\r\n    if (analysis.is_misparked && activeBooking) {\r\n      // Update booking parking status\r\n      await supabase\r\n        .from(\"bookings\")\r\n        .update({\r\n          parking_status: \"misparked\",\r\n        })\r\n        .eq(\"id\", activeBooking.id)\r\n\r\n      // Check if penalty already exists for this booking\r\n      const { data: existingPenalty } = await supabase\r\n        .from(\"penalties\")\r\n        .select(\"*\")\r\n        .eq(\"booking_id\", activeBooking.id)\r\n        .eq(\"penalty_type\", \"misparking\")\r\n        .eq(\"status\", \"pending\")\r\n        .single()\r\n\r\n      if (!existingPenalty) {\r\n        const penaltyAmount = 50.0\r\n        const { data: penalty } = await supabase\r\n          .from(\"penalties\")\r\n          .insert({\r\n            booking_id: activeBooking.id,\r\n            lot_id: lotId,\r\n            user_id: activeBooking.user_id,\r\n            penalty_type: \"misparking\",\r\n            amount: penaltyAmount,\r\n            reason: `Parking quality score: ${analysis.quality_score}/100. ${analysis.warnings.join(\". \")}`,\r\n            status: \"pending\",\r\n          })\r\n          .select()\r\n          .single()\r\n\r\n        // Send notifications\r\n        await Promise.all([\r\n          sendPushNotification(activeBooking.user_id, {\r\n            title: \"Misparking Detected!\",\r\n            body: `Quality score: ${analysis.quality_score}/100. Please reposition your vehicle. Penalty: $${penaltyAmount}`,\r\n            data: { type: \"misparking\", bookingId: activeBooking.id, penaltyId: penalty?.id },\r\n          }),\r\n          sendPushNotification(lot.user_id, {\r\n            title: \"Misparking Alert\",\r\n            body: `Vehicle misparked at ${lot.name}, Spot ${spot_number}. Quality: ${analysis.quality_score}/100`,\r\n            data: { type: \"misparking_owner\", bookingId: activeBooking.id, lotId },\r\n          }),\r\n        ])\r\n      }\r\n    } else if (!analysis.is_misparked && activeBooking?.parking_status === \"misparked\") {\r\n      // Car was repositioned correctly\r\n      await supabase\r\n        .from(\"bookings\")\r\n        .update({\r\n          parking_status: \"normal\",\r\n        })\r\n        .eq(\"id\", activeBooking.id)\r\n\r\n      await sendPushNotification(activeBooking.user_id, {\r\n        title: \"Parking Corrected\",\r\n        body: `Thank you for repositioning your vehicle. Quality score: ${analysis.quality_score}/100`,\r\n        data: { type: \"parking_corrected\", bookingId: activeBooking.id },\r\n      })\r\n    }\r\n\r\n    // Handle entry\r\n    if (event_type === \"entry\" && activeBooking) {\r\n      if (activeBooking.status === \"upcoming\") {\r\n        await supabase.from(\"bookings\").update({ status: \"active\" }).eq(\"id\", activeBooking.id)\r\n      }\r\n\r\n      await sendPushNotification(lot.user_id, {\r\n        title: \"Vehicle Entry\",\r\n        body: `Vehicle entered ${lot.name}, Spot ${spot_number}`,\r\n        data: { type: \"entry\", bookingId: activeBooking.id, lotId },\r\n      })\r\n    }\r\n\r\n    // Handle exit\r\n    if (event_type === \"exit\" && activeBooking) {\r\n      await supabase.from(\"bookings\").update({ status: \"completed\" }).eq(\"id\", activeBooking.id)\r\n\r\n      // Increment available_spots safely using the last-known lot value from sensorConfig\r\n      try {\r\n        const currentAvailable = Number(lot.available_spots ?? 0)\r\n        await supabase\r\n          .from(\"parking_lots\")\r\n          .update({\r\n            available_spots: currentAvailable + 1,\r\n          })\r\n          .eq(\"id\", lotId)\r\n      } catch (err) {\r\n        // Fallback: attempt plain update without raw arithmetic\r\n        await supabase.from(\"parking_lots\").update({}).eq(\"id\", lotId)\r\n      }\r\n\r\n      await Promise.all([\r\n        sendPushNotification(activeBooking.user_id, {\r\n          title: \"Parking Session Completed\",\r\n          body: `Thank you for using ${lot.name}`,\r\n          data: { type: \"exit\", bookingId: activeBooking.id },\r\n        }),\r\n        sendPushNotification(lot.user_id, {\r\n          title: \"Vehicle Exit\",\r\n          body: `Vehicle exited ${lot.name}, Spot ${spot_number}`,\r\n          data: { type: \"exit_owner\", bookingId: activeBooking.id, lotId },\r\n        }),\r\n      ])\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      event,\r\n      analysis,\r\n      message: analysis.warnings.length > 0 ? analysis.warnings.join(\". \") : \"Parking data recorded successfully\",\r\n    })\r\n  } catch (error) {\r\n    console.error(\"[v0] Sensor webhook error:\", error)\r\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 })\r\n  }\r\n}\r\n\r\n// Helper function to send push notifications\r\nasync function sendPushNotification(\r\n  userId: string,\r\n  payload: {\r\n    title: string\r\n    body: string\r\n    data?: any\r\n  },\r\n) {\r\n  try {\r\n    const supabase = await createClient()\r\n\r\n    // Get user's push subscriptions\r\n    const { data: subscriptions } = await supabase.from(\"push_subscriptions\").select(\"*\").eq(\"user_id\", userId)\r\n\r\n    if (!subscriptions || subscriptions.length === 0) {\r\n      console.log(\"[v0] No push subscriptions found for user:\", userId)\r\n      return\r\n    }\r\n\r\n    // Note: In production, you would use web-push library here\r\n    // For now, this is a placeholder that logs the notification\r\n    console.log(\"[v0] Would send push notification to user:\", userId, payload)\r\n\r\n    // TODO: Implement actual web push using web-push library\r\n    // const webpush = require('web-push')\r\n    // for (const subscription of subscriptions) {\r\n    //   await webpush.sendNotification(\r\n    //     {\r\n    //       endpoint: subscription.endpoint,\r\n    //       keys: {\r\n    //         p256dh: subscription.p256dh,\r\n    //         auth: subscription.auth\r\n    //       }\r\n    //     },\r\n    //     JSON.stringify(payload)\r\n    //   )\r\n    // }\r\n  } catch (error) {\r\n    console.error(\"[v0] Error sending push notification:\", error)\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}